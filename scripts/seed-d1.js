#!/usr/bin/env node
/**
 * Step 9 — D1 database seeding.
 * Reads data/names.json, data/popularity.json, data/categories.json, data/variants.json
 * and generates SQL to seed Cloudflare D1 (or runs it via wrangler).
 * Tables: names, name_popularity, name_categories, name_variants.
 * Enables edge queries, analytics, and future AI features.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const ROOT = path.join(__dirname, '..');
const DATA_DIR = path.join(ROOT, 'data');
const SEED_SQL_PATH = path.join(ROOT, 'seed-d1.sql');

const BATCH_SIZE = 500;

function loadJson(name) {
  const p = path.join(DATA_DIR, name + '.json');
  if (!fs.existsSync(p)) return [];
  try {
    const data = JSON.parse(fs.readFileSync(p, 'utf8'));
    return Array.isArray(data) ? data : [];
  } catch (e) {
    console.warn('Skip', p, e.message);
    return [];
  }
}

function esc(s) {
  if (s == null) return 'NULL';
  return "'" + String(s).replace(/'/g, "''") + "'";
}

function num(n) {
  if (n == null || n === '') return 'NULL';
  const v = Number(n);
  return Number.isNaN(v) ? 'NULL' : String(v);
}

function run() {
  const names = loadJson('names');
  const popularity = loadJson('popularity');
  const categories = loadJson('categories');
  const variants = loadJson('variants');

  if (names.length === 0) {
    console.error('data/names.json is empty or missing. Run export-json-data first.');
    process.exit(1);
  }

  // Deduplicate popularity by (name_id, country, year) — schema has UNIQUE(name_id, country, year).
  // Keep row with best (lowest) rank, then highest count.
  const popByKey = new Map();
  for (const r of popularity) {
    const key = `${r.name_id}\t${r.country}\t${r.year}`;
    const existing = popByKey.get(key);
    if (!existing) {
      popByKey.set(key, r);
      continue;
    }
    const rRank = r.rank != null ? r.rank : Infinity;
    const exRank = existing.rank != null ? existing.rank : Infinity;
    if (rRank < exRank || (rRank === exRank && (r.count || 0) > (existing.count || 0))) {
      popByKey.set(key, r);
    }
  }
  const popularityDeduped = Array.from(popByKey.values());

  const out = [];

  out.push('-- D1 seed generated by scripts/seed-d1.js');
  out.push('-- Tables: names, name_popularity, name_categories, name_variants');
  out.push('');

  out.push('DELETE FROM name_variants;');
  out.push('DELETE FROM name_categories;');
  out.push('DELETE FROM name_popularity;');
  out.push('DELETE FROM names;');
  out.push('');

  for (let i = 0; i < names.length; i += BATCH_SIZE) {
    const batch = names.slice(i, i + BATCH_SIZE);
    const values = batch.map((n) => {
      const id = num(n.id);
      const name = esc(n.name);
      const gender = esc(n.gender);
      const origin_country = n.origin_country != null ? esc(n.origin_country) : 'NULL';
      const language = n.language != null ? esc(n.language) : 'NULL';
      const meaning = n.meaning != null ? esc(n.meaning) : 'NULL';
      const meaning_source = n.meaning_source != null ? esc(n.meaning_source) : 'NULL';
      const origin_source = n.origin_source != null ? esc(n.origin_source) : 'NULL';
      const confidence_score = n.confidence_score != null ? num(n.confidence_score) : 'NULL';
      const phonetic = n.phonetic != null ? esc(n.phonetic) : 'NULL';
      const syllables = num(n.syllables);
      const first_letter = n.first_letter != null ? esc(n.first_letter) : 'NULL';
      const is_traditional = num(n.is_traditional ?? 0);
      const is_modern = num(n.is_modern ?? 0);
      return `(${id},${name},${gender},${origin_country},${language},${meaning},${meaning_source},${origin_source},${confidence_score},${phonetic},${syllables},${first_letter},${is_traditional},${is_modern})`;
    });
    out.push(
      'INSERT INTO names (id,name,gender,origin_country,language,meaning,meaning_source,origin_source,confidence_score,phonetic,syllables,first_letter,is_traditional,is_modern) VALUES '
    );
    out.push(values.join(',\n') + ';');
    out.push('');
  }

  for (let i = 0; i < popularityDeduped.length; i += BATCH_SIZE) {
    const batch = popularityDeduped.slice(i, i + BATCH_SIZE);
    const values = batch.map((r) => {
      const name_id = num(r.name_id);
      const country = esc(r.country);
      const year = num(r.year);
      const rank = num(r.rank);
      const count = num(r.count);
      return `(${name_id},${country},${year},${rank},${count})`;
    });
    out.push('INSERT INTO name_popularity (name_id,country,year,rank,count) VALUES ');
    out.push(values.join(',\n') + ';');
    out.push('');
  }

  for (let i = 0; i < categories.length; i += BATCH_SIZE) {
    const batch = categories.slice(i, i + BATCH_SIZE);
    const values = batch.map((r) => `(${num(r.name_id)},${esc(r.category)})`);
    out.push('INSERT INTO name_categories (name_id,category) VALUES ');
    out.push(values.join(',\n') + ';');
    out.push('');
  }

  for (let i = 0; i < variants.length; i += BATCH_SIZE) {
    const batch = variants.slice(i, i + BATCH_SIZE);
    const values = batch.map((r) => `(${num(r.name_id)},${esc(r.variant)},${esc(r.language)})`);
    out.push('INSERT INTO name_variants (name_id,variant,language) VALUES ');
    out.push(values.join(',\n') + ';');
    out.push('');
  }

  fs.writeFileSync(SEED_SQL_PATH, out.join('\n'), 'utf8');
  console.log('Wrote', SEED_SQL_PATH);
  console.log('  names:', names.length, 'rows');
  console.log('  name_popularity:', popularityDeduped.length, 'rows (deduped from', popularity.length, ')');
  console.log('  name_categories:', categories.length, 'rows');
  console.log('  name_variants:', variants.length, 'rows');

  const d1Database = process.env.D1_DATABASE || process.env.WRANGLER_D1_DATABASE;
  if (d1Database) {
    try {
      execSync(`npx wrangler d1 execute ${d1Database} --remote --file=${SEED_SQL_PATH}`, {
        stdio: 'inherit',
        cwd: ROOT,
      });
      console.log('D1 seed applied (remote).');
    } catch (e) {
      console.warn('wrangler d1 execute failed. Apply manually: npx wrangler d1 execute <DB_NAME> --remote --file=seed-d1.sql');
    }
  } else {
    console.log('To apply to D1: npx wrangler d1 execute <DB_NAME> --remote --file=seed-d1.sql');
    console.log('Or set D1_DATABASE=<DB_NAME> and re-run to apply automatically.');
  }
}

run();
